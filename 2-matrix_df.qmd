# Manipula√ß√£o e Visualiza√ß√£o de Dados

Aqui falarei sobre a manipula√ß√£o e visualiza√ß√£o que a modelagem demanda. Por√©m, o material melhor estar√° no livro de R, RFCD, dado a disponibilidade do tidyverse. Aqui, comentarei muito mais rapidamente sobre as contrapartes no Python.

---


# 1. Numpy

## 1.1 Introdu√ß√£o

O que √© Numpy? De acordo com o [site oficial](https://numpy.org/doc/stable/index.html):

> NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.

Antes de tudo, vamos [instalar](https://numpy.org/install/) e carregar a biblioteca:

```{python}
import numpy as np
```

### O conceito de arrays

O conceito que encapsula as principais novidades que a biblioteca traz √© o de _array_, e sua diferen√ßa com listas.

Em termos simplificados, podemos entender os arrays como um novo tipo de cole√ß√£o, uma cole√ß√£o homog√™nea/at√¥mica, em oposi√ß√£o √† listas, heterog√™neas/gen√©ricas. Isto √©: todos os elementos de um array s√£o do mesmo "tipo", o que n√£o √© uma necessidade em listas.

Veja exemplos abaixo, e se poder√£o ou n√£o ser entendidos como arrays:

- `[1]` poder√°.
- `[1, 2]` poder√°.
- `[1, "a"]` n√£o poder√°, tem elementos de tipos diferentes.
- `[1, [1, 2]]` n√£o poder√°, tem elementos de tipos diferentes (inteiro e uma cole√ß√£o).

Alguns exemplos mais complexos:

- `[[1, 2], [3, 4]]` poder√°! Arrays podem "conter si mesmos", mas, especialmente, entenda isso como arrays podem ser "organizados em m√∫ltiplas dimens√µes". No caso, seria um array bidimensional, uma matriz com linhas e colunas.
- `[[1, 2], [3, 4, 5]]` n√£o poder√°! Essa √© outra novidade, os arrays devem ser "retangulares", dentro de cada dimens√£o, todos os elementos devem ter o memso tamanho. Isso ficar√° mais claro a diante.
- E `[[1, 2], [3, "a"]]`? N√£o poder√°. Tudo dentro de um array tem que ter o mesmo tipo. Tamb√©m podemos pensar que, dentro de uma dimens√£o, tudo deve poder ser entendida como um array.

Ok, ent√£o, um array √© um caso espec√≠fico de uma lista, √© uma lista com duas restri√ß√µes:

- Todos os elementos devem ter o mesmo "tipo".
- Deve ser retangulares.






### Benef√≠cios do numpy

Porque isso √© √∫til? O que ganhamos com essa perda de generaliza√ß√£o?

Na vida real, muitas vezes nos deparamos com esse tipo de dado. Em bases de dado, normalmente cada coluna √© uma vari√°vel, uma cole√ß√£o de valores de um mesmo tipo. Al√©m disso, s√£o incont√°veis os lugares onde matrizes aparecem, e n√£o apenas as bidimensionais.

Criar um framework que seja especializado nesses casos gera tr√™s benef√≠cios principais:

- O cl√°ssico trade-off especializa√ß√£o-qualifica√ß√£o, o numpy √© **muito** eficiente em realizar opera√ß√µes com esse tipo de dado. E o essa √© uma das maiores propagandas que o numpy faz.
    - Inclusive, por tr√°s dos panos, a n√≠vel t√©cnico, arrays s√£o objetos bem diferentes de listas.
- A cria√ß√£o de ferramentas especialmente intuitivas e √∫teis para o contexto.
- Facilita√ß√£o do escopo, fica muito mais simples e intuitivo elencar as ferramentas que queremos ter para trabalhar.
    - Pense em como buscar as ferramentas relevantes para limpar uma base de dados, na documenta√ß√£o dos m√©todos de listas e bibliotecas math, stat, etc. Versus buscar as ferramentas na documenta√ß√£o do numpy.

### Vetoriza√ß√£o

A principal ferramenta/conceito criada para o contexto, para o "modo de pensar com arrays" √© a vetoriza√ß√£o.

Eu tenho certeza que voc√™s j√° tentaram fazer algo como `[1, 2, 3] * 2`, e tiveram vontade de desistir da programa√ß√£o ao ver que o resultado foi `[1, 2, 3, 1, 2, 3]` e  n√£o `[2, 4, 6]`.

Porque isso acontece? Lembre que listas s√£o gen√©ricas: √© √≥bvio o que `[1, "a", [3, 4]] * 2` deveria retornar? N√£o! Para cada elemento, o s√≠mbolo `*` √© o mesmo, mas as opera√ß√µes s√£o completamente diferentes. N√£o √© t√£o natural aplicar transforma√ß√µes elemento-a-elemento em cole√ß√µes gen√©ricas.

Agora, arrays, s√£o homog√™neos, √© muito mais natural aplicar uma transforma√ß√£o elemento-a-elemento. Normalmente, quando estamos trabalhando com arrays, √© porque √© esse o tipo de transforma√ß√£o que queremos fazer. O numpy sabe disso, e as faz de um jeito muito eficiente. Esse √© o conceito de transforma√ß√µes vetorizadas.

Vamos deixar isso mais claro com exemplos. Mas antes, veja um exemplo do ganho de efici√™ncia com a vetoriza√ß√£o:

```{python}
n = 10000000
a1 = np.arange(n)
l1 = list(range(n))
%timeit a1 * 2
%timeit [x * 2 for x in l1]
```

## 1.2 B√°sico sobre arrays

### Cria√ß√£o e forma

Para criar arrays, use a fun√ß√£o [numpy.array](https://numpy.org/doc/stable/reference/generated/numpy.array.html):

```{python}
a1 = np.array([1, 1, 1])
a2 = np.array([[1, 0, 1], [3, 4, 1]])
a3 = np.array([[[1, 7, 9], [5, 9, 3]], [[3,2,1], [4,5,6]]])
for a in [a1, a2, a3]: print(a, "\n")
```

<img src="https://www.plus2net.com/python/images/np-dimensions.jpg" width="400">

Note que come√ßamos a "contar" pelo vetor, depois pelas linhas, depois pelas matrizes, etc.

Para estudar o formato de um array, usamos `.shape`. Tamb√©m podemos usar as fun√ß√µes `len()`, e `.ndim`:

```{python}
for a in [a1, a2, a3]: print(a.shape, a.ndim, len(a), sep = " -- ")
```

Arrays s√£o costumeiramente chamados de _ndarrays_, arrays _n_ dimensionais.

**Arrays importados**

Podemos salvar arrays em arquivos, usando fun√ß√µes como:

- [numpy.save](https://numpy.org/doc/stable/reference/generated/numpy.save.html): salva como um "arquivo array" ".npy".
- [numpy.savetxt](https://numpy.org/doc/stable/reference/generated/numpy.savetxt.html): salva como um arquivo CSV, adequado apenas para arrays 1D e 2D.
- [A biblioteca pickle](https://docs.python.org/3/library/pickle.html): uma bilbioteca que consegue "conservar" qualquer objeto do python, mas pode ser demorado.

Similarmente, podemos importar arquivos, com fun√ß√µes `numpy.load` e `numpy.loadtxt`.

Por fim, √© comum converter outros objetos em arrays. Veja as fun√ß√µes [numpy.asarray](https://numpy.org/doc/stable/reference/generated/numpy.asarray.html) e [pandas.Series.to_numpy](https://pandas.pydata.org/pandas-docs/version/0.24.0rc1/api/generated/pandas.Series.to_numpy.html).

**Arrays placeholders**

Tamb√©m podemos criar arrays com valores comuns, temos v√°rias fun√ß√µes, como:

- [numpy.empty](https://numpy.org/doc/stable/reference/generated/numpy.empty.html): cria um array vazio com a forma especificada.
- [numpy.ones](https://numpy.org/doc/stable/reference/generated/numpy.ones.html): cria um array preenchido com uns.
- [numpy.zeros](https://numpy.org/doc/stable/reference/generated/numpy.zeros.html): cria um array preenchido com zeros.
- [numpy.full](https://numpy.org/doc/stable/reference/generated/numpy.full.html): cria um array preenchido com um valor constante.
- [numpy.eye](https://numpy.org/doc/stable/reference/generated/numpy.eye.html): cria uma matriz identidade.
- [numpy.linspace](https://numpy.org/doc/stable/reference/generated/numpy.linspace.html): cria um array com valores espa√ßados uniformemente dentro de um intervalo.
- [numpy.arange](https://numpy.org/doc/stable/reference/generated/numpy.arange.html): cria um array com valores espa√ßados uniformemente dentro de um intervalo especificado.

```{python}
print("Empty: \n", np.empty((2, 3)), "\n")
print("Ones: \n", np.ones((2, 3)), "\n")
print("Zeros: \n", np.zeros((2, 3)), "\n")
print("Full: \n", np.full((2, 3), 5), "\n")
print("Eye: \n", np.eye(3), "\n")
print("Linspace: \n", np.linspace(0, 10, num=5), "\n")
print("Arange: \n", np.arange(0, 10, 2), "\n")
```

Para mais informa√ß√£o sobre cria√ß√£o de arrays, veja [API Ref. ‚Üí Routines ‚Üí Array creation](https://numpy.org/doc/stable/reference/routines.array-creation.html):

- [Criando por forma e valor](https://numpy.org/doc/stable/reference/routines.array-creation.html#from-shape-or-value).
- [Criando por dados](https://numpy.org/doc/stable/reference/routines.array-creation.html#from-existing-data), e [API Ref. ‚Üí Routines ‚Üí I/O](https://numpy.org/doc/stable/reference/routines.io.html).
- [Criando por ranges](https://numpy.org/doc/stable/reference/routines.array-creation.html#numerical-ranges).
- [Criando matrizes](https://numpy.org/doc/stable/reference/routines.array-creation.html#building-matrices).

### Random

O numpy tem uma parte da biblioteca focada na gera√ß√£o de n√∫meros aleat√≥rios, [numpy.random](https://numpy.org/doc/stable/reference/random/index.html). Se tiver curiosidade, leia mais sobre como computadores geram [n√∫meros pseudo-aleat√≥rios](https://www.revista-programar.info/artigos/pseudorandom-number-generators-prngs/).

Todas as distribui√ß√µes que voc√™ pensar podem ser geradas pelo numpy:

- Uniforme: [numpy.random.uniform](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.uniform.html).
    - Uniforme 0-1: [numpy.random.random](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.random.html).
    - Uniforme discreta A-B: [numpy.random.integers](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.integers.html).
- Binomial: [numpy.random.binomial](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.binomial.html).
- Normal: [numpy.random.normal](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.normal.html).
- Poisson: [numpy.random.poisson](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.poisson.html).
- Samplear um array: [numpy.random.choice](https://numpy.org/doc/stable/reference/random/generated/numpy.random.Generator.choice.html).

```{python}
print(np.random.uniform(0, 1, 5), "\n")
print(np.random.normal(0, 1, size=(3, 3)))
```

### Tipos de arrays

Mais cedo, falamos que todos os elementos de um arrays tem sempre o mesmo "tipo". Em termos simplificados, o nome normalmente associado √† "tipo" √© _dtype_.

Um elemento (um "escalar") pode ter v√°rios tipos, mas os mais comuns s√£o:

- `int_`: n√∫meros inteiros (_integer_).
- `float_`: n√∫meros de ponto flutuante (_floating-point_). O tipo padr√£o.
- `bool_`: valores booleanos (`True` ou `False`).
- `str_`: _strings_ de texto.
- E outros menos utilizados: `complex_`: n√∫meros complexos, `object_`: objetos Python gen√©ricos, `datetime64`: datas e hor√°rios, `timedelta64`: diferen√ßas entre datas e hor√°rios, `category`: categorias ou r√≥tulos.

**Alguns coment√°rios mais t√©cnicos:**

Na realidade, embora exista o conceito de "n√∫mero inteiro", e o Python s√≥ defina um tipo de dado _integer_, existem muitas maneiras de representar um n√∫mero na mem√≥ria do computador. O numpy se importa com isso, e existem v√°rios tipos para cada um dos conceitos acima.

- Por conta disso, o dtype pode aparecer com nomes diferentes como _int64_.
- Se voc√™ for muito nerd, talvez isso importe para o seu projeto. Para escolher um tipo espec√≠fico use a fun√ß√£o `np.array` com o argumento `dtype = ...`. Leia mais sobre isso [aqui](https://numpy.org/doc/stable/reference/arrays.scalars.html#arrays-scalars-built-in).
- O tipo de um array `x` pode ser descoberto com `x.dtype` e `x.dtype.name`.

Mas e se eu tentar criar o array `[1, "a"]`? O numpy usa _coer√ß√£o_, ele converte todos os elementos a um mesmo tipo, de acordo com uma lista de prioridade. De maneira simples, _int_ ‚Üí _float_ ‚Üí _string_. Voc√™ tamb√©m pode converter um array para outro tipo usando o m√©todo `x.astype()`. Veja exemplos abaixo.

```{python}
print(np.array([[1,2], [3.0, 4]]), "\n")
print(np.array([[1,2], [3.0, "4.0"]]), "\n")
print(np.array([[1,2], [3, 4]], dtype = np.complex_), "\n")
print(np.array([[1,2], [3, 4]]).astype(str), "\n")
```

Para mais informa√ß√µes sobre arrays, como funcionam, como s√£o salvos na mem√≥ria, veja [API Ref. ‚Üí Array objects](https://numpy.org/doc/stable/reference/arrays.html). Cuidado, muitos temas t√©cnicos e desnecess√°rios (para o momento).

Especialmente, foram ignorados dois t√≥picos de arrays:

- Os _masked arrays_, arrays com valores faltantes, [API Ref. ‚Üí Array objects ‚Üí Masked arrays](https://numpy.org/doc/stable/reference/maskedarray.html).
- E os _datetime arrays_, arrays de datas, [API Ref. ‚Üí Array objects ‚Üí Datetimes and Timedeltas](https://numpy.org/doc/stable/reference/arrays.datetime.html).

### M√©todos

Na aula passada voc√™s aprenderam que no Python, a maior parte dos construtos da linguagem s√£o classes, e isso n√£o √© exce√ß√£o para os _ndarrays_. Cada array √© um objeto, uma inst√¢ncia dessa classe, e tem seus m√©todos.

A lista completa de m√©todos pode ser vista na [documenta√ß√£o da classe](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html). Alguns interessantes s√£o:

- `.tolist()`.
- `.sum()` e `.prod()`; `.cumsum()` e `.cumprod()`.
- `.all()` e `.any()`.
- `.max()` e `.min()`; `.argmax()` e `.argmin()`.
- `mean()`, `.var()` e `.std()`.
- `.sort()`; `.argsort()`.
- `.choose()`.
- `.round()`.
- Em breve, vamos falar um pouco mais sobre:
    - `.resise()`, `.reshape()`, e `.transpose()`; `flatten()` e  `.ravel()`.
    - `.copy()` e `.view()`.

## 1.3 Opera√ß√µes com Arrays

Lembre-se que o ponto mais importante √© a vetoriza√ß√£o. O numpy define "fun√ß√µes universais", fun√ß√µes que podem ser aplicadas de forma vetorizadas.

Os exemplos abaixo s√£o bem expositivos, s√£o as fun√ß√µes que voc√™s j√° conhecem, apresentadas rapidamente.

#### Opera√ß√µes aritm√©tricas

Veja mais em [API Ref. ‚Üí Routines ‚Üí Mathematical functions](https://numpy.org/doc/stable/reference/routines.math.html).

```{python}
a1, a2 = np.array([1,2,3]), np.array([4,5,6])

print(np.subtract(a1, a2), "\n") #a1 + a2
print(np.divide(a1, a2), "\n") #a1 * a2
print(np.exp(a1), "\n")
print(np.sqrt(a1), "\n")
print(np.sin(a1), "\n")
print(np.log(a1), "\n")
```

Tamb√©m considere as constantes abaixo. Mais informa√ß√µes em [API Ref. ‚Üí Constants](https://numpy.org/doc/stable/reference/constants.html).

```{python}
np.pi, np.e, np.nan, np.inf
```

#### Opera√ß√µes matriciais

Veja mais em [API Ref. ‚Üí Routines ‚Üí Linear algebra](https://numpy.org/doc/stable/reference/routines.linalg.html).

```{python}
a1, a2 = np.array([(1,2), (-1,-3)]), np.array([(4,5), (-4,-6)]) # Note o uso, indiferenci√°vel, de tuplas

print(a1 * a2, "\n")
print(np.dot(a1, a2), "\n") #a1 @ a2
print(np.linalg.matrix_power(a1, 3), "\n")
print(np.linalg.det(a1), "\n")
print(np.linalg.inv(a1), "\n")
print(np.linalg.norm(a1), "\n")
print(np.linalg.eig(a1), "\n")
```

#### Opera√ß√µes com strings

Veja mais em [API Ref. ‚Üí Routines ‚Üí String operations](https://numpy.org/doc/stable/reference/routines.char.html).

```{python}
a1, a2 = np.array(['ol√°', 'oi', 'oopa']), np.array([', tudo bem?', ', bem?', ', b√£o?'])

print(np.char.add(a1, a2), "\n")
print(np.char.multiply(a1, [3, 1, 2]), "\n")
print(np.char.capitalize(a1), "\n")
print(np.char.count(a1, 'o'), "\n")
print(np.char.find(a1, 'o'), "\n")
```

#### Opera√ß√µes l√≥gicas/de compara√ß√£o

Veja mais em [API Ref. ‚Üí Routines ‚Üí Logic functions](https://numpy.org/doc/stable/reference/routines.logic.html). Tamb√©m veja opera√ß√µes de sets em [API Ref. ‚Üí Routines ‚Üí Set functions](https://numpy.org/doc/stable/reference/routines.set.html).

```{python}
a1, a2 = np.array([(1,2), (-1,-3)]), np.array([(4,5), (-4,-6)])

print(np.greater(a1, a2), "\n") #a1 > a2
print((a1 == a2).any(), "\n") #note the usage of ()
print(np.logical_or(a1 > 1, a2 < 0), "\n") #a1 > 1 or a2 < 0
```

#### Opera√ß√µes estat√≠sticas

Veja mais em [API Ref. ‚Üí Routines ‚Üí Statistics](https://numpy.org/doc/stable/reference/routines.statistics.html).

```{python}
a1 = np.random.normal(0, 1, 100000)
a2 = a1 + np.random.normal(0, 0.5, 100000)

print(np.mean(a1), "\n")
print(np.median(a1), "\n")
print(np.std(a1), "\n")
print(np.quantile(a1, 0.25), "\n")
print(np.corrcoef(a1, a2), "\n")
```

## 1.4 Subsetting e Copying

A refer√™ncia b√°sica est√° em [User guide ‚Üí Indexing on ndarrays](https://numpy.org/doc/stable/user/basics.indexing.html).

A indexa√ß√£o de arrays √© feita de forma similar √† listas, com `a1[algo]`. A maioria das t√©cnicas dispon√≠veis para listas est√° dispon√≠vel aqui tamb√©m.

Essa parte √© bem √∫til, porque l√≥gicas similares de indexa√ß√£o podem ser utilizadas no pandas e em listas.

### Subseting b√°sico

Com uma dimens√£o, √© simples. Conseguimos utilizar a t√©cnica de indexes negativos.

```{python}
a1 = np.array([1, 2, 3, 4])
print(a1, "\n")

print(a1[0])
print(a1[-1])
```

E com duas dimens√µes? Agora, temos que informar o que queremos pegar de cada dimens√£o, `a2[algo1, algo2]`:

```{python}
a2 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(a2, "\n")

print(a2[0, 1])
```

E se eu quiser selecionar mais do que um elemento? Aqui, tamb√©m √© poss√≠vel utilizar a t√©cnica de slicing `:`.

```{python}
print(a1[1:3])
print(a1[1:])
print(a1[:2])
print(a1[:])
```

Com duas dimens√µes √© a mesma ideia, lembrando que precisamos falar o que queremos pegar de ambas as dimens√µes, as possibilidades aumentam.

```{python}
print(a2[0, 0:2])
print(a2[0:2, 1])
print(a2[1:, :])
```

Com _n_ dimens√µes √© a mesma ideia, com uma entrada em `[]` para cada dimens√£o.

Se tiver curiosidade, veja dois truques usando `...` e `None` nos √≠ndices [aqui](https://numpy.org/doc/stable/user/basics.indexing.html#dimensional-indexing-tools).

```{python}
an = np.arange(3**3).reshape(3, 3, 3)

print(an[2, 2, 2])
print(an[0, :, :])
```

Quando voc√™ ficar pica, vai descobrir que d√° para omitir dimens√µes, como abaixo. Mas por enquanto, n√£o inventa, coloque um "algo" para cada dimens√£o, nem que o "algo" seja "selecione tudo" (`:`).

```{python}
print(a3[0:])
```

Note que essa no√ß√£o do subset deixa claro qual √© a "ordem" dos componentes de um array multidimensional. Isto √©, quando pedimos `for i in a3`, o que ser√° passado para `i`? Cada elemento? Cada coluna, cada linha? cada matriz?

```{python}
for i in a3:
    for j in mat:
        for k in row: print(i)
```

Vemos que, do array tridimensional `a3`, `i` s√£o as sub-matrizes, `j` s√£o as linhas de uma sub-matriz, e `i` os elementos de cada linha. Isto √©, a ordem √© da maior/√∫ltima/mais alta dimens√£o para a menor/mais baixa.

### Subseting avan√ßado

E se os √≠ndices que voc√™ quer obter est√£o em uma cole√ß√£o? Podemos utilizar cole√ß√µes de inteiros ou booleanos para acessar √≠ndices tamb√©m!

```{python}
print(a1[np.array([1, 2])]) #a1[[1, 2]]
a1[np.array([True, False, False, True])] #print(a1[[True, False, False, True]])
```

Note que para booleanos, o √≠ndice-cole√ß√£o precisa ser do mesmo tamanho da dimens√£o relevante.

O legal, √© que da para utilizar isso para criar _filtros_:

```{python}
print(a1[a1 + 1 > 2])
```

Existem muitas outras t√©cnicas utilizando essas ferramentas. Veja mais [aqui](https://numpy.org/doc/stable/user/basics.indexing.html#advanced-indexing).

### Copy versus view

**Um √∫ltimo coment√°rio t√©cnico, eu juro!**

E aquela hist√≥ria insuport√°vel de `x = ...`, `y = x`, e uma mudan√ßa inocente em `y` quebrando seu c√≥digo porque `x` mudou tamb√©m? Como fica isso no numpy?

Segue existindo üò¥. Vou falar uma das frases j√° faladas abaixo, mas n√£o se assuste.

> No python, vari√°veis sempre s√£o nomes referenciados a valores, _mutating_ um valor -- diferente de _rebinding_ um valor -- mostrar√° essa mudan√ßa em todos os nomes associados √† ele.

Isto √©, essa quest√£o √© bem geral no python. Infelizmente, n√£o √© hora de entrar em detalhes na l√≥gica por tr√°s de tudo isso. Para saber mais, eu gosto muito [desse post](https://nedbatchelder.com/text/names.html).

O que precisamos saber agora √© que sim, ainda estamos preocupados em criar `.copy()`'s dos arrays. Como uma regra de bolso, a menos que voc√™ de fato queira a refer√™ncia ao objeto original, adicione o `.copy()`.

Note que essa quest√£o est√° bem presente: quando fazemos `y = x[1, :]`, y √© uma c√≥pia ou uma refer√™ncia? N√£o √© obvio, e varia de caso a caso. N√£o vou entrar em detalhes, mas o ponto √©, tome cuidado, e use c√≥pias sem medo.

Um √∫ltimo ponto, que tamb√©m n√£o merece detalhe, √© a exist√™ncia de uma "semi-c√≥pia", ou _shallow-copy_, `x.view()`. Quais s√£o as diferen√ßas, quando eu uso um ou o outro? Meia noite eu te conto. Brincadeira, mas realmente, n√£o vale falar sobre isso agora.

**Fim!**

Pronto! Voc√™s aprenderam o b√°sico de numpy! Agora, podemos aplicar esse novo jeito de pensar para bases de dados, e conhecer a biblioteca especializada nisso, o pandas. Especialmente, relembre do que aprendemos, sobre a maneira de se pensar em dados vetorizados.

Existem dois temas adicionais, manipula√ß√£o de arrays (mudar o formato, adicionar itens, combinar, e dividir), e fun√ß√µes universais (tecnicas poderosas que as fun√ß√µes do numpy habilitam).

# 2. Pandas

## 2.1 Introdu√ß√£o

O site oficial da biblioteca Pandas introduz ela da seguinte forma:


> "Pandas is a Python package providing fast, flexible, and expressive data structures **designed to make working with ‚Äúrelational‚Äù or ‚Äúlabeled‚Äù data** both easy and intuitive. It aims to be the fundamental high-level building block **for doing practical, real-world data analysis in Python**. (...) Pandas is **built on top of NumPy** and is intended to integrate well within a scientific computing environment with many other 3rd party libraries."

Veremos nessa aula as mais diversas aplica√ß√µes dessa biblioteca e seremos apresentados a "tipos" de dados semelhantes aos vistos anteriormente, por√©m, no Pandas.

Vamos come√ßar!

___

Para instala√ß√£o da biblioteca, basta utilizar do c√≥digo de instala√ß√£o:
```
# pip install pandas
```

*Em caso de d√∫vidas, recomendamos acessar a aba de instala√ß√£o do site: https://pandas.pydata.org/docs/getting_started/install.html*


---

### **Benef√≠cios do Pandas:**

Voc√™ est√° buscando uma maneira eficiente e poderosa de manipular e analisar dados em Python? Apresentamos o Pandas, a biblioteca que revoluciona a forma como lidamos com dados tabulares! √â a escolha ideal para qualquer pessoa que deseja realizar an√°lises de dados de maneira eficiente, flex√≠vel e poderosa em Python.

Alguns pontos de destaque da biblioteca s√£o:

- **Facilidade de Uso:** Manipule dados de forma simples e intuitiva, com estruturas de dados familiares como DataFrames e S√©ries, sem a complexidade de lidar diretamente com arrays ou listas.

- **Flexibilidade de Dados:** Armazene e trabalhe com dados de diferentes tipos (n√∫meros, strings, datas, booleanos) em uma √∫nica estrutura.

- **Opera√ß√µes Eficientes:** Realize opera√ß√µes de manipula√ß√£o de dados de forma r√°pida e eficiente, incluindo sele√ß√£o, filtragem, ordena√ß√£o, agrupamento, agrega√ß√£o e jun√ß√£o de dados de diferentes fontes.

- **Tratamento de Dados Ausentes:** Lide facilmente com valores ausentes (NaN) em seus dados, com m√©todos integrados para detec√ß√£o, preenchimento, remo√ß√£o ou substitui√ß√£o desses valores, garantindo a integridade dos seus resultados.

- **Integra√ß√£o com Outras Ferramentas:** Importe e exporte dados de e para uma variedade de formatos, como CSV, Excel, SQL, JSON, HTML, entre outros, facilitando a integra√ß√£o com outras ferramentas e sistemas.

- **Comunidade Ativa e Suporte:** Fa√ßa parte de uma comunidade vibrante de usu√°rios, com vasta documenta√ß√£o, tutoriais e suporte online, garantindo que voc√™ tenha o apoio necess√°rio para aproveitar ao m√°ximo o potencial do Pandas.

#### **Series e dataframe:**

O pandas se beneficia do uso de duas estruturas de dados principais (que se assemelham, at√© certo ponto, aos arrays que vimos anteriormente).

 A primeira delas, nomeada de *Series*, √© uma estrutura de dados **unidimensional** que pode conter qualquer tipo de dado, sendo semelhante a uma matriz unidimensional ou a uma coluna em uma tabela.

 O *dataframe* se difere das *Series* por ser uma estrutura de dados **bidimencional** que se organiza em linhas e colunas, semelhantes a uma tabela de banco de dados ou uma planilha do Excel, e s√£o muito usados em ci√™ncia de dados, an√°lises financeiras, pesquisas acad√™micas, entre outros.

## 2.2 B√°sico Sobre Series e Dataframes

### **Como podemos criar essas estruturas de dados?**

Para montarmos uma Series, utilizamos do comando pandas.Series(dados). Tenham em mente que esses dados podem estar em listas, dicin√°rios, arrays...

```{python}
import pandas as pd

s = pd.Series({"a":["a", "do", "le", "ta"],"b":["baby","shark"]})

s2 = pd.Series([1,2,3,4,"a"])

s3 = pd.Series([1,2]) #cria um index + dados

s4 = pd.Series([3,4],[7,8]) # usa o primeiro como dado + segundo como index

s4
```

J√° ao montarmos um DataFrame, usamos o comando pd.DataFrame(dados). Esses dados tem que ter o mesmo tamanho (lenght) para que possa ser criado.

```{python}
df = pd.DataFrame({"a":["a", "do", "le", "ta"], "b":["baby","shark","tutu","tuturu"]})
#dfErrado = pd.DataFrame({"e":["r","r","a","d","o"], "E":["r","r","o"]})
df
```

```{python}
# Podemos, tamb√©m, montar "na marra" o Data Frame:
df = pd.DataFrame([[19, 0, "F"], [20, 1, "F"], [60, 2, "M"]], index=["J√∫lia", "Mariana", "Antonio"], columns=['Nome', 'Filhos', 'Sexo'])
df
```

### **Outras Fontes:**

Podemos, a partir de dados da internet ou coleta de dados manuais, usar o Pandas para acessar base de dados. Segue alguns exemplos:



```
pd.read_excel(arquivo)
pd.read_CVS(arquivo)
pd.read_sql(arquivo)

```

Obs: o "arquivo" se refere a um url do arquivo ou um "endere√ßo" de arquivo no computador do usu√°rio.

*Mais ferramentas: https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html*

### Summarise:

De forma geral, temos algumas ferramentas principais para condensar dados com diferentes objetivos.

Antes disso, veremos alguma ferramentas √∫teis para poss√≠veis estudos da base:

* N√∫mero de Linhas e colunas no dataframe:

```
df.shape
```

```
df["valor"].value_counts() #retorna um n√∫mero inteiro
```

* N√∫mero de valores √∫nicos em uma coluna:

```
df["coluna"].nunique()
```

* Estat√≠sticas e Bescri√ß√µes B√°sicas para cada coluna:

```
df.describe()
```


O pandas fornece um grande conjunto de fun√ß√µes de resumo que operam em diferentes tipos de objetos do pandas (colunas de DataFrame, Series, GroupBy, Expanding e Rolling (ver abaixo)) e produzem valores √∫nicos para cada um dos grupos. Quando aplicado a um DataFrame, o resultado √© retornado como uma Series do pandas para cada coluna.

Importante: verifique o [link oficial](https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#descriptive-statistics) da p√°gina para saber mais

#### Group Data:

O "Group Data" (ou "Agrupamento de Dados") na biblioteca Pandas refere-se a uma opera√ß√£o fundamental de an√°lise de dados, na qual voc√™ divide um conjunto de dados em grupos com base em determinados crit√©rios e, em seguida, aplica opera√ß√µes ou fun√ß√µes a esses grupos. Isso √© feito principalmente usando o m√©todo .groupby() do Pandas.

Importante! Acesse  https://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html  para saber mais.

## 2.3 Subset

 Os subconjuntos s√£o por√ß√µes espec√≠ficas de um DataFrame que podem ser selecionadas com base em crit√©rios como linhas, colunas ou ambos.

 Existem tr√™s tipos principais de subconjuntos: linhas, colunas e linhas e colunas simultaneamente.

### Subset linhas

Para estudarmos os t√≥picos abaixo, vamos usar uma planilha fict√≠cia.

```{python}
import pandas as pd

arquivo = "Clientes.xlsx"
df = pd.read_excel(arquivo)

df
```

Nesse exemplo, a base de dados √© extremamente pequena ent√£o n√£o temos problema em rodarmos os dados. Em casos mais complexos, podemos pedir que o programa rode apenas os dados que precisamos para a manipula√ß√£o.

```{python}
#Podemos apenas rodar a primeira linha (r√≥tulos das colunas) quando a base √© muito grande
df.head()

#ou as primeiras x linhas
df.head(2)

#ou as √∫ltimas x linhas
df.tail()
df.tail(3)
```

Para mostrar alguma das f√≥rmulas que temos a nossa disposi√ß√£o, vamos imaginar que voc√™ √© estagi√°rio desse estabelecimento: quais dados podemos tirar dessa tabela?

```{python}
#Primeiramente, vamos ver se os dados respeitam uma sequ√™ncia l√≥gica
subset1 = df[df["Idade"]<100]  #n√£o faz sentido ter uma pessoa de mais de 100 anos

subset2 = subset1[subset1["Idade"] > 18]  #n√£o faz sentido um "cliente" ser menor de idade

subset3 = subset2.drop(columns = "Nome.1")

DF = subset3

DF
```

```{python}
#agora, vamos analisar mais a fundo a tabela:

Inad = DF[DF["Inadimplente"] == True]  #mais pra frente, ainda nessa aula, aprenderemos uma maneria relativamente mais simples para fazer isso (query)

N√£oInad = DF[DF["Inadimplente"] == False]

InadMaior = DF[(DF["Inadimplente"] == True) & (DF["Idade"] > 18)] #nessa base de dados, n√≥s j√° tiramos os Inad menores de idade mas vale o exemplo

Estado = DF[(DF["Estado"] == "SP") | (DF["Estado"] == "TO")]

MaisVelhos = DF.nlargest(3,"Idade")

MaisNovos = DF.nsmallest(3,"Idade")

#Inad
#N√£oInad
#InadMaior
#Estado
#MaisNovos
#MaisVelhos
```

Da mesma forma que podemos selecionar com base nos crit√©rios selecionados, podemos usar de fun√ß√µes que aleatorizem os dados:

```{python}
DF.sample(frac = 0.5) #aqui, pedimos para que o programa nos recorte uma fra√ß√£o aleat√≥ria do dataframe
```

```{python}
DF.sample(n=9) #ou podemos dar um valor para o tamanho da amostra aleat√≥ria
```

Outra ferramenta para essas sele√ß√µes √© a *query*. Seu maior diferencial √© que essa ferramenta permite usar a l√≥gica Booleana para filtrar as linhas.

```{python}
#A l√≥gica booleana faz com que o crit√©rio de sele√ß√£o seja verificar se uma afirma√ß√£o, a nossa escolha, √© verdadeira ou falsa

DF.query('Idade > 50') #ele seleciona cada linha que a resposta de Idade>50 == True
DF.query('Nome.str.len() > 5') #ele seleciona cada linha cujo comprimento do nome seja maior que 5

DF.query('Idade > 40 and Estado == "SP"')
DF.query('Inadimplente == True and D√≠vida > 1000')


DF.query('Nome.str.startswith("B")')
```

### Subset colunas

Agora, vamos avan√ßar para o pr√≥ximo passo e aprender como criar subconjuntos de colunas. Os subconjuntos de colunas nos permitem focar em vari√°veis espec√≠ficas dos nossos dados, facilitando a an√°lise e visualiza√ß√£o de informa√ß√µes relevantes.

```{python}
# Para selecionar apenas algumas colunas, temos um "modelo" base que seguimos
DF["Nome"]
DF.Nome

DF[["Nome","Idade"]]

DF[["Nome","Inadimplente","D√≠vida"]]

#e se quisermos o nome e a d√≠vida dos inadimplentes?
Corte1 = DF[["Nome", "Inadimplente", "D√≠vida"]]
Corte2 = Corte1[DF["Inadimplente"] == True]
Corte3 = Corte2[["Nome", "D√≠vida"]]

Corte3
```

### Subset os dois juntos

N√≥s vimos que podemos manipular a base de dados de forma a filtrarmos linhas e colunas de forma individual. Agora, veremos algumas fun√ß√µes que unificam essas tarefas, ou seja, **atua com as colunas e linhas**.

#### iloc e loc:

Come√ßando pelo *iloc*, essa fun√ß√£o √© usada para acessar os dados de um DataFrame usando √≠ndices inteiros. Voc√™ pode usar o iloc para selecionar linhas e colunas com base em sua posi√ß√£o num√©rica no DataFrame. Ou seja, temos a posi√ß√£o do que queremos e usamos ele para selecionar o necess√°rio.

J√° o *loc* √© usado para acessar os dados de um DataFrame usando r√≥tulos de √≠ndice. O loc permite selecionar linhas e colunas com base nos r√≥tulos definidos para o √≠ndice e as colunas. Ou seja, sabemos o que queremos mas buscamos sua posi√ß√£o.

```{python}
#DF.iloc[1,0]  #linha da posi√ß√£o 1 (segunda linha) na coluna de posi√ß√£o 0 (primeira coluna)

#DF.iloc[10:20] #Select rows 10-20.

DF.iloc[:, [1, 2, 4]] #Select columns in positions 1, 2 and 5  e todas as linhas

DF.iloc[[0,5,10,15],:] #Seleciona as linhas nas posi√ß√µes 0, 5, 10 e 15 e todas as colunas
```

```{python}
DF.loc[:, 'Idade':'Inadimplente'] #Select all columns between x2 and x4 (inclusive).

DF.loc["Jaime":"Fred", :] #Seleciona todas as linhas entre "Jaime" e "Fred"

DF.loc[df['Idade'] > 10, ['Inadimplente', 'Estado']]  #Select rows meeting logical condition, and only the specific columns .
  #s√≥ as linhas que
```

#### iat e at:

Essas ferramentas s√£o semelhantes ao 'iloc' e 'loc' que vimos, mas s√£o usados para acessar valores √∫nicos em um DataFrame, seja usando √≠ndices inteiros (posi√ß√µes) ou r√≥tulos de √≠ndice, respectivamente.

A ferramenta `iat` √© mais eficiente para acesso baseado em posi√ß√£o, se baseando em √≠ndices para achar o valor, enquanto `at` √© mais eficiente para acesso baseado em r√≥tulos.

```{python}
DF.iat[0,0] #primeira linha da primeira coluna

DF.iat[0,1] #primeira linha da segunda coluna

DF.iat[1,0] #segunda linha da primeira coluna

DF.iat[9,4] #d√©cima linha da quinta coluna
```

```{python}
DF.at[0, "Idade"] #n√≥s damos o r√≥tulo/index e a coluna na qual ele deve procura-lo
#DF.at[3, "Nome"]
```

Resumindo, use `iloc`/`loc` quando precisar acessar m√∫ltiplos valores ou fatias de dados e `iat`/`at` quando precisar acessar um √∫nico valor de forma eficiente. A escolha entre `iloc`/`loc` ou `iat`/`at` depende do tipo de opera√ß√£o que voc√™ est√° realizando e se est√° trabalhando com acessos √∫nicos ou m√∫ltiplos no DataFrame.

Resumindo, use `iloc`/`loc` quando precisar acessar m√∫ltiplos valores ou fatias de dados e `iat`/`at` quando precisar acessar um √∫nico valor de forma eficiente. A escolha entre `iloc`/`loc` ou `iat`/`at` depende do tipo de opera√ß√£o que voc√™ est√° realizando e se est√° trabalhando com acessos √∫nicos ou m√∫ltiplos no DataFrame.

## 2.4 Operar/Criar

#### Opera√ß√µes em colunas

```{python}
data = {'A': [1, 2, 3],
        'B': [4, 5, 6]}
df = pd.DataFrame(data)

df
```

```{python}
# Adicionando uma nova coluna
df['C'] = [7, 8, 9]

df
```

```{python}
# Renomeando uma coluna
df.rename(columns={'A': 'A_Novo'}, inplace=True)

df
```

```{python}
# Aplicando uma f√≥rmula a uma coluna
df['B_quadrado'] = df['B'].apply(lambda x: x ** 2)
df['B/2'] = df['B'].apply(lambda x: x / 2)

df['A+2'] = df['A_Novo'] + 2
df['A-2'] = df['A_Novo'] - 2

df
```

```{python}
# Removendo uma coluna
df.drop(columns=['B_quadrado'], inplace = True)

df
```

```{python}
# Adicionando duas colunas e armazenando o resultado em uma nova coluna
df['A+B'] = df['A_Novo'] + df['B']

df
```

```{python}
# Encontrando a soma de uma coluna
soma_B = df['B'].sum()
soma_B
```

```{python}
# Encontrando a m√©dia de uma coluna
media_B = df['B'].mean()

media_B
```

```{python}
# Filtrando linhas com base em uma condi√ß√£o em uma coluna
df_filtrado = df[df['A_Novo'] > 2]

df_filtrado
```

```{python}
# Aplicando a fun√ß√£o 'sqrt' a todos os elementos da coluna 'C'
import numpy as np
df['C'] = np.sqrt(df['C'])

df
```

#### Opera√ß√µes em linhas e c√©lulas

```{python}
# Aplicando uma fun√ß√£o em todas as linhas
soma_por_linha = df.sum(axis=1)

soma_por_linha
```

```{python}
# Selecionando uma c√©lula espec√≠fica
valor_celula = df.at[0, 'B']

valor_celula
```

```{python}
# Atualizando o valor de uma c√©lula espec√≠fica
df.at[0, 'B'] = 100

df
```

```{python}
# Aplicando uma fun√ß√£o em uma c√©lula espec√≠fica
df.at[0, 'B'] = df.at[0, 'B'] * 2

df
```

```{python}
# Removendo uma linha pelo √≠ndice
df.drop(index=0, inplace=True)

df
```

```{python}
# Inserindo uma nova linha

data = {'A': [1, 2, 3],
        'B': [4, 5, 6]}
df = pd.DataFrame(data)

# Novas linhas a serem adicionadas
novas_linhas = pd.DataFrame({'A': [10, 11], 'B': [20, 21]})

# Concatenando os dois DataFrames
df = pd.concat([df, novas_linhas], ignore_index=True)

df
```

```{python}
# Ordenando o DataFrame por uma coluna espec√≠fica
df = df.sort_values(by='A')

df
```

### Lidar com dados NA

```{python}
data2 = {'A': [1, 2, 3, 4],
        'B': [np.nan, 6, 7, np.nan],
        'C': [10, np.nan, np.nan, 13]}
df_na = pd.DataFrame(data2)
```

```{python}
# Encontrar valores NA (ausentes) em um DataFrame
df_na.isna()
```

```{python}
# Remover colunas com valores ausentes
df_na.dropna(axis=1, inplace=True)

df_na
```

```{python}
# Remover linhas com valores ausentes
df_na.dropna(axis=0, inplace=True)

df_na
```

```{python}
# Preencher valores NA com um valor espec√≠fico (por exemplo, zero)
df_na.fillna(0, inplace=True)

df_na
```

# Temas Adicionais

## 1.5 Numpy - Manipulating Arrays

Existem outras quatro opera√ß√µes relacionadas a manipular arrays como um todo: alterar a forma, adicionar/remover elementos, combinar, e dividir. Essa parte n√£o √© t√£o importante, e as fun√ß√µes s√£o simples, vamos v√™-las rapdiamente.

### Alterar a forma

Veja as fun√ß√µes/m√©todos:

- [`.resize()`](https://numpy.org/doc/stable/reference/generated/numpy.resize.html) e [`reshape()`](https://numpy.org/doc/stable/reference/generated/numpy.reshape.html): para alterar a forma de um array, passando a nova forma como uma tupla.
- [`transpose()`](https://numpy.org/doc/stable/reference/generated/numpy.transpose.html): transpor arrays.
- [`.flatten()`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flatten.html) e [`.ravel()`](https://numpy.org/doc/stable/reference/generated/numpy.ravel.html): achatar arrays.

### Adicionar e remover elementos

Veja os fun√ß√µes:

- `append()`, `insert()`, e `delete()`.

### Combinar

Veja as fun√ß√µes:

- [`concatenate()`](https://numpy.org/doc/stable/reference/generated/numpy.concatenate.html).
- [`vstack()`](https://numpy.org/doc/stable/reference/generated/numpy.vstack.html),  e [`hstack()`](https://numpy.org/doc/stable/reference/generated/numpy.hstack.html).

### Dividir

Veja as fun√ß√µes:

- [`.hsplit()`](https://numpy.org/doc/stable/reference/generated/numpy.hsplit.html) e [`.vsplit()`](https://numpy.org/doc/stable/reference/generated/numpy.vsplit.html).

## 1.6 Numpy - Fun√ß√µes Universais

Existe um √∫ltimo t√≥pico interessante, mas mais avan√ßado. As fun√ß√µes do numpy s√£o bem poderosas e flex√≠veis. √â poss√≠vel:

- Aplic√°-las para cada dimens√£o separadamente -- usando o argumento `axis=`.
- Filtrar dimens√µes para n√£o aplicar -- usando o argumento `where=`
- Aplicar de modo a "acumular" ou "reduzir" o resultado -- usando os m√©todos `.accumulate()` e `.reduce()`.

Aprendam sobre esses t√≥picos em [Api Ref. ‚≠¢ Universal functions](https://numpy.org/doc/stable/reference/ufuncs.html). Adicionalmente, Tamb√©m vejam algumas t√°ticas avan√ßadas em [Api Ref. ‚≠¢ Routines ‚≠¢ Functional programming](https://numpy.org/doc/stable/reference/routines.functional.html).

Abaixo apresento alguns exemplos sem contexto nenhum.

```{python}
a1 = np.array([1,2,3])

np.add.accumulate(a1)
np.add.reduce(a1)
```

```{python}
a2 = np.array([[1,2], [4,5]])

print(np.add.accumulate(a2, axis = 0))
print(np.add.reduce(a2, axis = 0))
```

```{python}
where1 = [True, True, False]
where2 = [[True, False, False], [False, True, False], [False, False, True]]

print(np.add.reduce(a1, 0, where = where1), "\n")
print(np.add.reduce(a2, 0, where = where2), "\n")
```

## 2.5 Pandas - Reshape

Primeiro, vamos baixar uns exemplos:

```{python}
tables_links = {
    'df1': 'https://raw.githubusercontent.com/tidyverse/tidyr/c6c126a61f67a10b5ab9ce6bb1d9dbbb7a380bbd/data-raw/table1.csv',
    'df2': 'https://raw.githubusercontent.com/tidyverse/tidyr/c6c126a61f67a10b5ab9ce6bb1d9dbbb7a380bbd/data-raw/table2.csv',
    'df3': 'https://raw.githubusercontent.com/tidyverse/tidyr/c6c126a61f67a10b5ab9ce6bb1d9dbbb7a380bbd/data-raw/table3.csv',
    'df4a': 'https://raw.githubusercontent.com/tidyverse/tidyr/c6c126a61f67a10b5ab9ce6bb1d9dbbb7a380bbd/data-raw/table4a.csv',
    'df4b': 'https://raw.githubusercontent.com/tidyverse/tidyr/c6c126a61f67a10b5ab9ce6bb1d9dbbb7a380bbd/data-raw/table4b.csv',
    'df5': 'https://raw.githubusercontent.com/tidyverse/tidyr/c6c126a61f67a10b5ab9ce6bb1d9dbbb7a380bbd/data-raw/table6.csv'
}

for i in tables_links.keys():
    globals()[i] = pd.read_csv(tables_links[i])
```

### Reordenar

Linhas:

```{python}
df1.sort_values(by='cases', ascending=False)
```

E colunas

```{python}
df1.reindex(columns=['year', 'cases', 'population', 'country'])
```

### Renomear

Colunas:

```{python}
df1.rename(columns={'cases': 'new_cases', 'population': 'new_population'}, inplace=False)
```

Linhas:

```{python}
df1.rename({0: 'Row1', 1: 'Row2', 2: 'Row3', 3: 'Row4', 4: 'Row5', 5: 'Row6'})
```

### Remodelar

Wide to long (melt):

```{python}
print(df4a)
pd.melt(df4a, id_vars = ["country"], var_name = "year", value_name = "cases")
```

Long to wide (pivot)

```{python}
print(df2)
pd.pivot(df2, index = ["country", "year"], columns = "type", values = "count")
```

### Separar e unir colunas

Separar:

```{python}
print(df3, "\n")

df3[["cases", "population"]] = df3["rate"].str.split("/", expand = True)
df3 = df3.drop("rate", axis = 1)
print(df3)
```

Unir:

```{python}
print(df5, "\n")

df5["year"] = df5["century"] + df5["year"]
df5 = df5.drop("century", axis = 1)
print(df5)
```

## 2.6 Pandas - Combinar

### Concatenar

Veja a fun√ß√£o:
- [`.concat()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html?highlight=concat#pandas.concat)

### Merge

Veja as fun√ß√µes abaixo para [unir dataframes](https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html) de maneiras diferentes:

**Standard Joins:**

- [`.merge()`]()


**Filtering Joints:**

- [`.isin()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.isin.html?highlight=isin#pandas.DataFrame.isin)




<!-- mais coisa -->

---
title: Introdu√ß√£o √† Ci√™ncia de Dados e Data Wrangle
jupyter: python3
---



# 1. Introdu√ß√£o

Esta aula marca uma divis√£o no curso de trainee. At√© agora, voc√™s estavam aprendendo v√°rias ferramentas √∫teis, mas sem um objetivo espec√≠fico al√©m de simplesmente aprender a programar em Python. Nesta aula, vamos apresentar o objetivo, voc√™s ir√£o aprender a realizar "projetos de Ci√™ncia de Dados".

A aula est√° organizada como segue:

- 1 Introdu√ß√£o.
    - 1.1 Recapitulando: vamos recapitular as ferramentas aprendidas at√© aqui, e trazer aten√ß√£o para os conceitos/modos de pensar mais gerais, que motivaram essas ferramentas.
    - 1.2 Projetos de ci√™ncia de dados: iremos apresentar o que √© Ci√™ncia de Dados, e quais s√£o as etapas de um projeto comum: data wrangle, explora√ß√£o, e comunica√ß√£o.
- 2 Data Wrangle.
    - 2.1 Tidy: a primeira etapa de um projeto √© "arrumar" os dados, e existe uma no√ß√£o bem clara do que √© _tidy data_. Vamos mostrar como as ferramentas do pandas podem ser utilizadas nessa etapa.
    - 2.2 Transforma√ß√£o: ap√≥s arrumar os dados, pode-mos transform√°-los para habilitar as etapas da visualiza√ß√£o e modelagem. Tamb√©m iremos relacionar com as ferramentas do pandas.
- 3 Visualiza√ß√£o: outra parte do ciclo √© a visualiza√ß√£o, tanto via _summary statistics_ (3.1), quanto via gr√°ficos (3.2). Vamos apresentar a biblioteca matplotlib e como utiliz√°-la nesse contexto.

## 1.1 Recapitulando

Nas tr√™s primeiras aulas do curso, voc√™s aprenderam diversas ferramentas. Veja o diagrama abaixo, e atente por:

- Relembrar as ferramentas em si.
    - Tenha certeza que voc√™ de fato sabe todos esses temas.
- Agora com essa vis√£o de cima, veja os conceitos mais gerais de ci√™ncia da computa√ß√£o associados √†s ferramentas.
    - O foco do curso n√£o foi explicar essas generaliza√ß√µes, mas elas s√£o muito √∫teis, tanto para entender melhor como o python funciona, quanto para facilitar aprender outras linguagens no futuro.
- Veja como as ferramentas condicionam novas maneiras de pensar em dados/problemas.
    - Na √∫ltima aula, voc√™s aprenderam o conceito de vetores homog√™neos, e o novo modo de pensar da vetoriza√ß√£o. Mais especificamente, tamb√©m aprenderam a maneira de pensar em "bases de dados"

Na aula de hoje, voc√™s v√£o aprender dois novos contextos: (i) um tipo espec√≠fico de organiza√ß√£o de bases de dados, os _dados tidy_, e (ii) a maneira de usar dados tidy para resolver problemas, com a Ci√™ncia de Dados, e as etapas de seus projetos.

Adicionalmente, v√£o ver novas ferramentas: para a parte de arruma√ß√£o de dados, voc√™s j√° a conhecem, √© o pandas, mas para a visualiza√ß√£o, v√£o aprender a biblioteca gr√°fica matplotlib.

<img src="https://i.imgur.com/aaeCsMB.png" width="800">

## 1.2 Projetos de Ci√™ncia de Dados

### A Ci√™ncia de Dados

A Ci√™ncia de Dados √© um campo gigante, que nasceu via uma demanda de expandir a estat√≠stica para vias de "learn from data", "more emphasis on data preparation and presentation rather than statistical modeling", e "emphasis on prediction rather than inference". Atualmente, o termo n√£o √© super bem definido, e o campo tem muita intersec√ß√£o com outras disciplinas.

De acordo com a Wikipedia:

> Data science is an interdisciplinary academic field that uses statistics, scientific computing, scientific methods, processes, algorithms and systems to extract or extrapolate knowledge and insights from data.

Fontes: ["50 Years of Data Science" (2017)](https://www.tandfonline.com/doi/full/10.1080/10618600.2017.1384734) e [Wikipedia](https://en.wikipedia.org/wiki/Data_science).

### As etapas de um projeto

Mais interessante que ficar tentando definir a disciplina, vamos entend√™-la na pr√°tica. Como a aula √© minha, e eu fa√ßo o que eu quiser, vou utilizar a explica√ß√£o do livro ["R for Data Science"](https://r4ds.had.co.nz/index.html).

Um projeto comum, no geral, se parece como abaixo. Veja uma breve explica√ß√£o de cada t√≥pico.

<img src="https://d33wubrfki0l68.cloudfront.net/571b056757d68e6df81a3e3853f54d3c76ad6efc/32d37/diagrams/data-science.png" height="200">

#### Importing

A primeira etapa √© a importa√ß√£o. Alguns coment√°rios:

- Os dados podem vir de v√°rias fontes, como arquivos locais, bancos de dados, APIs (application programming interface), ou de sites (via web scrapping). 
- Os dados podem estar em v√°rios formatos como CSV, Excel, JSON, entre outros. √â interessante ter um conhecimento b√°sico de como cada um funciona.
- Cada tipo de fonte tem uma maneira diferente de se interagir, e cada formato exige sua pr√≥pria fun√ß√£o. Para os casos mais simples, o pandas (e qualquer outra biblioteca de dataframes), tem fun√ß√µes para I/O.

N√£o vamos entrar em detalhes nesse tema. N√£o √© algo super extenso nem complexo, e existem muitas refer√™ncias online. Uma das mais completas que achei foi [esse tutorial da RealPython](https://realpython.com/pandas-read-write-files/).

#### Tidy

A pr√≥xima etapa √© arrumar, _tidy_, os dados. Vamos falar sobre isso com mais detalhe, mas existe uma no√ß√£o bem espec√≠fica do que s√£o dados arrumados, _tidy data_.

As tr√™s pr√≥ximas etapas existem dentro de um ciclo.

#### Transform

Mesmo com dados j√° arrumados, ainda temos o interesse de transform√°-los, para conseguir obter insights novos da mesma base de dados. Na aula de hoje, vamos dar alguns exemplos de interesses, e este tema ficar√° mais claro.

Visualizar e modelar os dados trar√° novos insights e novas demandas, de modo que estamos constantemente transformando os dados para criar novas visualiza√ß√µes e modelagens.

_Tidy_ e _transform_ juntos s√£o chamados de _data wrangling_.

#### Visualize

Aqui, serei pregui√ßoso, o texto do Hadley Wickham √© muito bom:

> Visualisation is a fundamentally human activity. A good visualisation will show you things that you did not expect, or raise new questions about the data. A good visualisation might also hint that you‚Äôre asking the wrong question, or you need to collect different data. Visualisations can surprise you, but don‚Äôt scale particularly well because they require a human to interpret them.

#### Model

Um modelo √©, em termos simplificados e a depender do contexto, um conjunto de hip√≥teses sobre o mundo -- sobre o processo gerador dos dados --, acrescido com um m√©todo matem√°tico e computacional de estimar esse processo.

> Models are a fundamentally mathematical or computational tool, so they generally scale well. (...) But every model makes assumptions, and by its very nature a model cannot question its own assumptions. That means a model cannot fundamentally surprise you.

#### Comunication

O √∫ltimo passo √© comunica√ß√£o. As linguagens de programa√ß√£o prov√©m ferramentas para expor seus resultados. O pr√≥prio Jupyter Notebook onde esta aula foi escrita √© um exemplo disso. Mas existem muitas outras ferramentas mais avan√ßadas para criar reports, livros, p√°ginas na web, aplicativos, etc. No curso de trainee, n√£o iremos cobrir essa etapa com detalhe.

Por fim, dos √∫ltimos coment√°rios. Primeiro, e a programa√ß√£o?

> Surrounding all these tools is programming. Programming is a cross-cutting tool that you use in every part of the project. You don‚Äôt need to be an expert programmer to be a data scientist, but learning more about programming pays off because becoming a better programmer allows you to automate common tasks, and solve new problems with greater ease.

E o que falta?

No curso do trainee iremos explicar todas as etapas (fora comunica√ß√£o), mas √© s√≥ isso que voc√™ precisar√°? N√£o, cada projeto exige seu conhecimento espec√≠fico, em cada tema, cada disciplina, existem conceitos pr√≥prios que entrar√£o em alguma das etapas aqui descritas. Mas tudo bem, o importante √© voc√™s saberem a base, e conseguir√£o ir atr√°s do adicional por conta pr√≥pria.

### A Organiza√ß√£o de um script

Acima temos as etapas "te√≥ricas" de um projeto, mas como um script √© organizado na pr√°tica? Normalmente nas seguintes se√ß√µes:

- Introdu√ß√£o:
    - Descri√ß√£o do problema.
    - Descri√ß√£o dos dados (fontes, quest√µes t√©cnicas, etc.).
    - Setup do c√≥digo (importar m√≥dulos, definir fun√ß√µes, etc.).
- Importar e arrumar:
    - Importar os dados **[importar]**.
    - Transform√°-los em um dataframe tidy **[arrumar]**.
    - Lidar com NAs **[arrumar]**.
- Pr√©-processamento dos daods:
    - Analisar cada vari√°vel, seu tipo, valores NA/NaN, e mais:
        - Vari√°veis categ√≥ricas -- categorias, distribui√ß√£o **[visualizar]**..
        - Vari√°veis num√©ricas -- range, distribui√ß√£o **[vis.]**.
    - Corrigir problemas observados **[transformar]**.
- An√°lise explorat√≥ria:
    - Explorar a rela√ß√£o entre as vari√°veis, especialmente entre os x's e os y's.
    - Y bin√°rio: distribui√ß√£o condicional em cada x **[vis.]**.
    - Y cont√≠nuo: distribui√ß√£o conjunta em cada x **[vis.]**.
    - Conseguir insights sobre o problema e transformar/criar vari√°veis para a modelagem **[trans.]**.
- Modelagem:
    - Dividir base em treino e teste, balancear os dados **[trans.]**.
    - Definir os modelos e aplic√°-los. Variar os hiperpar√¢metros **[modelar]**.
    - Visualizar os resultados [**vis.**].
    - Adquirir insights, transformar os dados de acordo, e remodelar **[trans.]** **[modelar]**.
- Comunicar:
    - Gerar uma visualiza√ß√£o final com os pontos principais do processo e principais resultados **[vis.]**.
    - Comunicar os resultados **[comunicar]**.

Todas essas etapas ser√£o explicadas na pr√°tica na aula 6, ent√£o n√£o se preocupem tanto por enquanto.

# 2. Data Wrangle

### Tidy

#### Tidy data

[You can represent the same underlying data in multiple ways. The example below shows the same data organised in four different ways. Each dataset shows the same values of four variables country, year, population, and cases, but each dataset organises the values in a different way.]

<img src="https://imgur.com/XA7JWwS.png" height="400">

<img src="https://imgur.com/nN0ouP9.png" height="400">

[These are all representations of the same underlying data, but they are not equally easy to use. One dataset, the tidy dataset, will be much easier to work with inside the tidyverse.

There are three interrelated rules which make a dataset tidy:

- Each variable must have its own column.
- Each observation must have its own row.
- Each value must have its own cell.

Figure 12.1 shows the rules visually.
]

<img src="https://d33wubrfki0l68.cloudfront.net/6f1ddb544fc5c69a2478e444ab8112fb0eea23f8/91adc/images/tidy-1.png" height="200">

[
Why ensure that your data is tidy? There are two main advantages:

- There‚Äôs a general advantage to picking one consistent way of storing data. If you have a consistent data structure, it‚Äôs easier to learn the tools that work with it because they have an underlying uniformity.

- There‚Äôs a specific advantage to placing variables in columns because it allows R‚Äôs vectorised nature to shine. As you learned in mutate and summary functions, most built-in R functions work with vectors of values. That makes transforming tidy data feel particularly natural.
]

#### Arrumando datasets

Agora que j√° entendemos o que √© tidy data, podemos adquirir a habilidade de olhar para um dataset e, sabendo onde queremos chegar, elencar quais s√£o as altera√ß√µes a serem feitas -- "remover esta linha", "dividir essa coluna no meio".

Ap√≥s elencar quais altera√ß√µes devem ser feitas, √© simples fazer a ponte de quais _manipula√ß√µes de dados voc√™ quer fazer_ -- "subset linhas" e "separar colunas".

Por fim, s√≥ falta relembrar como √© o c√≥digo que aplica essa manipula√ß√£o. Essa √© a parte mais simples! √â s√≥ voltar na aula passada, pesquisar na internet, _ver no chat_, ou perguntar para o seu amigo preferido!

Tendo as duas primeiras habilidades, voc√™ tem tudo o que precisa para pesquisar, e n√£o h√° problema nenhum em ter que pesquisar, o problema √© ter que pesquisar , e n√£o saber como!. Agora, se voc√™ s√≥ sabe a terceira, voc√™ n√£o precisa pesquisar, mas _n√£o sabe o que voc√™ n√£o precisa pesquisar_, o que n√£o √© especialmente √∫til.

Se voc√™ quiser ficar insano no pandas, rever a aula passada tr√™s vezes por dia, deitado numa banheira congelada, ser√° √≥timo, voc√™ ficar√° efici√™nte muito r√°pidamente. Mas n√£o precisa, essa efici√™ncia vem com o tempo, e o mais importante √© saber a l√≥gica de  "o que precisa alterar" e "quais s√£o as manipula√ß√µes que existem".

Ok, sem mais delongas, vamos aprender a elencar altera√ß√µes, vamos ver uns exemplos [vide o PPT](https://docs.google.com/presentation/d/1VZQdPhCVgatuJxwFHgmUVGAN6TcJwyOw/edit?usp=sharing&ouid=116517596014032888777&rtpof=true&sd=true).

Qual foi a receitinha de bolo que aprendemos? (hmm bolo üòã). Recebemos um dataset, e:

- Arrumar os dados para o formato data frame.
    - Todas as colunas s√£o homog√™neas?
        - Remover linhas "ruins", converter valores.
    - Todas as colunas s√£o do mesmo tamanho?
        - Remover linhas "ruins".
- Arrumar os dados para o formato tidy.
    - Toda coluna √© uma vari√°vel?
        - Remover colunas "ruins".
        - Separar/unir colunas colunas.
    - Toda linha √© uma observa√ß√£o?
        - Quais s√£o as vari√°veis que definem uma observa√ß√£o?
        - Pivot e melt.
    - Toda c√©lula √© um valor?
        - Transformar dados "ruins" em NA.
        - Lidar com dados NA.
- Tenho mais de um dataset? Deix√°-los tidy e ent√£o realizaram algum merge.

### Transform

Ap√≥s arrumarmos um dataset, ainda aplicaremos transforma√ß√µes com base nas demandas da fase de visualiza√ß√£o e modelagem.

- Manipular linhas.
    - Sorting.
    - Sampling.
    - Filtrar observa√ß√µes.
- Transformar/criar colunas:
    - Alterar a unidade de uma vari√°vel.
    - Normalizar vari√°veis.
    - Agrupar as categorias de uma vari√°vel categ√≥rica.
    - Corrigir/formatar texto de vari√°veis string.
    - Manipular datas.
    - Criar novas colunas a partir de opera√ß√µes com m√∫ltiplas outras Exemplos: sal√°rio semanal * semanas trabalhadas; idade ao quadrado.
    - Criar uma coluna para ajudar em um plot.

Todas essas opera√ß√µes s√£o fact√≠veis de serem feitas com base na aula passada de pandas. Voc√™s ver√£o muitos exemplos dessa etapa na aula 6.

# 3. Visualiza√ß√£o

## 3.1 Sumarisa√ß√£o dos Dados

[Maneiras de conseguir "resumir" dados, criar estat√≠sticas descritivas em cima de uma base de dado]

[Alguns links:

https://pandas.pydata.org/docs/getting_started/intro_tutorials/06_calculate_statistics.html
https://www.geeksforgeeks.org/pandas-groupby-summarising-aggregating-and-grouping-data-in-python/
https://www.geeksforgeeks.org/pandas-groupby-summarising-aggregating-and-grouping-data-in-python/]

Vamos come√ßar carregando dados:

```{python}
import pandas as pd
```

```{python}
df = pd.read_csv("https://drive.google.com/uc?id=1u2MEH_DTBMyG3clVKA4Q5FEpntLZNKeE")
df
```

### Sumarisando o dataframe como um todo

[fun√ß√µes .info() e .describe(). tem mais alguma fun√ß√£o tipo essas?]

### Sumarisando vari√°veis categ√≥ricas

[explicar o .value_counts. mais algum m√©todo legal?]

```{python}
counts = df['Fuel_Type'].value_counts(normalize = True)

print(counts)
counts.plot(kind = "bar")
```

### Sumarisando vari√°veis cont√≠nuas

[explicar as estat√≠sticas de .describe, density, e boxplot. mais algum m√©todo legal?]

As estat√≠sticas descritivas principais est√£o na tabela "describe", mas tamb√©m podem ser obtidas individualmente.

```{python}
print(df['Price'].mean()) # Tamb√©m existe .sum(), .min(), etc.

df['Price'].describe()
```

De modo mais geral, mas menos mensur√°vel, podemos olhar para a distribui√ß√£o da vari√°vel como um todo, e uma visualiza√ß√£o simplificada com boxplots.

```{python}
df['Price'].plot.density()
```

```{python}
df['Price'].plot.box()
```

### Analisando grupos nos dados

[explicar fazer esses summaries com groupby, e usando o argumento by=... nas fun√ß√µes de plotting. ver https://www.shanelynn.ie/summarising-aggregation-and-grouping-data-in-python-pandas/ por exemplo]



<!-- mais coisa -->

---
title: Visualiza√ß√£o de Dados
jupyter: python3
---


[Parte do material abaixo ainda √© composto de refer√™ncias, e n√£o √© 100% autoral, mas tudo teve pelo menos contribui√ß√µes pessoais.]


## GGPlot

[a fazer]

## Matplotlib

[a fazer]

[alguns links: https://matplotlib.org/stable/users/explain/quick_start.html;
https://matplotlib.org/3.8.3/users/index.html;
https://matplotlib.org/cheatsheets/_images/cheatsheets-1.png;
https://matplotlib.org/3.8.3/index.html, https://matplotlib.org/3.8.3/api/index.html]
### Anatomia de uma figura

<img src="https://matplotlib.org/stable/_images/anatomy.png" width="300">

- Figure
- Axis
- Artist

[explicar isso dai]
### O estilo da programa√ß√£o

[explicar https://matplotlib.org/stable/users/explain/quick_start.html#coding-styles por cima e apresentar um exemplo)
### Plots

[explicar os plots poss√≠veis]
### Est√©tica

[alterando a est√©tica dos dados, isto √©, cores, markers, etc.]
### Tema

[alterando a est√©tica da figura (n√£o dos dados), isto √©, eixos, t√≠tulo, etc.]
### Plots combinados

[subplots e tals]
